<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI情报局 - 自动化排版系统</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Noto+Sans+SC:wght@300;400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
        }
        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }
        .cyber-card {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 248, 0.2);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.05);
        }
        .neon-text-blue {
            color: #22d3ee;
            text-shadow: 0 0 8px rgba(34, 211, 238, 0.6);
        }
        .neon-text-green {
            color: #4ade80;
            text-shadow: 0 0 8px rgba(74, 222, 128, 0.6);
        }
        .highlight-cyber {
            color: #22d3ee; /* Cyber Blue */
            font-weight: 700;
            background: rgba(34, 211, 238, 0.1);
            padding: 0 4px;
            border-radius: 2px;
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // 默认输入内容，用于演示
        const DEFAULT_INPUT = `### AI 进化日报：代码消亡与代理崛起
基于 X 平台高价值情报深度筛选 | 2025.12.27
编程的定义正在被**彻底重写**。Andrej Karpathy 发出的信号表明，我们正从“代码编写者”转型为**AI 代理（Agents）的指挥官**。这不仅是工具的迭代，更是生产力逻辑的**范式转移**——从手动敲击字符转向管理上下文、权限与工作流。

#### 1. 编程范式重构
- **关键动态**：知名开发者 Andrej Karpathy 指出，编程职业正经历剧烈重塑。传统的代码贡献正在减少，取而代之的是对 **AI 代理（Agents）**、**提示词（Prompts）**、**MCP** 及 **IDE 集成** 等新抽象层的管理。
- **商业信号**：资本将从传统软件开发工具转向 **AI 代码生成器** 与 **智能代理生态系统**。
- **实操建议**：开发者需停止死磕底层语法，转而精通 **Prompt Engineering** 与 **工作流编排**。

#### 2. 工具与生产力变现
- **新工具**：**Cursor IDE**（编程辅助）、**Midjourney/DALL-E**（图像生成）。
- **使用场景**：利用 AI 代理自动化处理 **Excel 数据流**，或为自媒体/小企业快速生成 **高质量视觉物料**。
- **搞钱思路**：利用**信息差**进行降维打击。1）技术向：用 AI 快速生成 Python 自动化脚本；2）设计向：在 **小红书/Etsy** 出售数字资产。

#### 3. 行业风向与争议
- **专家观点**：Jeremy Howard 强调，AI 艺术工具（如 **Stable Diffusion**）的逼真度已引发本质探讨。
- **潜在风险**：**技术性失业**风险加剧。`;

        // 解析高亮语法的组件：将 **text** 转换为带样式的 span
        const HighlightParser = ({ text }) => {
            if (!text) return null;
            // 正则匹配 **内容**
            const parts = text.split(/(\*\*.*?\*\*)/g);
            return (
                <span>
                    {parts.map((part, index) => {
                        if (part.startsWith('**') && part.endsWith('**')) {
                            return (
                                <span key={index} className="highlight-cyber">
                                    {part.slice(2, -2)}
                                </span>
                            );
                        }
                        return part;
                    })}
                </span>
            );
        };

        const App = () => {
            const [input, setInput] = useState(DEFAULT_INPUT);
            const [parsedData, setParsedData] = useState({
                title: '',
                subtitle: '',
                abstract: [],
                sections: []
            });

            // 核心解析逻辑
            useEffect(() => {
                const lines = input.split('\n');
                let title = '';
                let subtitle = '';
                let abstractLines = [];
                let sections = [];
                
                let currentSection = null;
                let parsingState = 'init'; // init, afterTitle, abstract, inSection

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line && parsingState !== 'abstract') continue; // Skip empty lines unless processing abstract paragraph

                    // 1. 识别大标题 ###
                    if (line.startsWith('### ')) {
                        title = line.replace('### ', '');
                        parsingState = 'afterTitle';
                        continue;
                    }

                    // 2. 识别副标题 (紧跟标题后，包含"基于"或年份数字)
                    if (parsingState === 'afterTitle') {
                        if (line.includes('基于') || /\d{4}/.test(line)) {
                            subtitle = line;
                            parsingState = 'abstract';
                            continue;
                        } else {
                            // 如果不符合副标题规则，直接进入摘要解析，并把当前行作为摘要第一行
                            parsingState = 'abstract';
                            // Fall through to abstract logic
                        }
                    }

                    // 3. 识别版块标题 ####
                    if (line.startsWith('#### ')) {
                        // 如果之前有正在处理的 section，先保存
                        if (currentSection) {
                            sections.push(currentSection);
                        }
                        // 开启新 section
                        currentSection = {
                            title: line.replace('#### ', ''),
                            items: []
                        };
                        parsingState = 'inSection';
                        continue;
                    }

                    // 4. 解析内容
                    if (parsingState === 'abstract') {
                        if (line) abstractLines.push(line);
                    } else if (parsingState === 'inSection' && currentSection) {
                        if (line.startsWith('- ')) {
                            currentSection.items.push({
                                type: 'list',
                                content: line.replace('- ', '')
                            });
                        } else if (line) {
                            // 版块内的普通文本（非列表项）
                            currentSection.items.push({
                                type: 'text',
                                content: line
                            });
                        }
                    }
                }
                // 循环结束后，保存最后一个 section
                if (currentSection) {
                    sections.push(currentSection);
                }

                setParsedData({
                    title,
                    subtitle,
                    abstract: abstractLines,
                    sections
                });

            }, [input]);

            const copyToClipboard = () => {
                 // 简单的复制文本功能，复制编辑器的内容
                navigator.clipboard.writeText(input).then(() => {
                    alert('Markdown 源码已复制');
                });
            };

            return (
                <div className="min-h-screen flex flex-col md:flex-row">
                    {/* 左侧编辑器 */}
                    <div className="w-full md:w-1/2 p-6 border-r border-slate-800 flex flex-col h-screen">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold text-slate-400 flex items-center gap-2">
                                <span className="w-3 h-3 bg-blue-500 rounded-full animate-pulse"></span>
                                输入源 (Markdown)
                            </h2>
                            <button 
                                onClick={() => setInput('')}
                                className="text-xs text-slate-500 hover:text-red-400 transition-colors"
                            >
                                清空
                            </button>
                        </div>
                        <textarea
                            className="w-full flex-1 bg-slate-900/50 text-slate-300 p-4 rounded-lg font-mono text-sm border border-slate-700 focus:border-blue-500 focus:outline-none resize-none leading-relaxed"
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            placeholder="在此粘贴清洗后的文本..."
                        />
                    </div>

                    {/* 右侧预览区 */}
                    <div className="w-full md:w-1/2 bg-slate-950 p-6 overflow-y-auto h-screen relative">
                         <div className="absolute top-6 right-6 z-10">
                            <button 
                                onClick={copyToClipboard}
                                className="bg-blue-600/20 hover:bg-blue-600/40 text-blue-400 border border-blue-500/50 px-3 py-1 rounded text-xs transition-all"
                            >
                                复制源码
                            </button>
                        </div>

                        {/* 渲染容器 */}
                        <div className="max-w-2xl mx-auto space-y-8 pb-20">
                            
                            {/* 头部区域 */}
                            <header className="space-y-4 border-b border-slate-800 pb-6">
                                <h1 className="text-4xl md:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400 leading-tight">
                                    {parsedData.title || "等待输入..."}
                                </h1>
                                
                                {parsedData.subtitle && (
                                    <div className="flex items-center gap-2 text-sm md:text-base text-slate-400 font-mono">
                                        <span className="text-green-500">>></span>
                                        {parsedData.subtitle}
                                    </div>
                                )}
                            </header>

                            {/* 摘要区域 */}
                            {parsedData.abstract.length > 0 && (
                                <div className="cyber-card p-6 rounded-xl relative overflow-hidden">
                                    <div className="absolute top-0 left-0 w-1 h-full bg-blue-500"></div>
                                    <p className="text-slate-300 leading-relaxed text-lg">
                                        {parsedData.abstract.map((line, i) => (
                                            <React.Fragment key={i}>
                                                <HighlightParser text={line} />
                                                <br/>
                                            </React.Fragment>
                                        ))}
                                    </p>
                                </div>
                            )}

                            {/* 版块列表 */}
                            <div className="space-y-8">
                                {parsedData.sections.map((section, idx) => (
                                    <section key={idx} className="group">
                                        <h3 className="text-2xl font-bold text-white mb-4 flex items-center gap-3">
                                            <span className="text-3xl font-mono text-slate-700 select-none group-hover:text-blue-500 transition-colors">
                                                0{idx + 1}.
                                            </span>
                                            <span className="border-b-2 border-transparent group-hover:border-green-500 transition-all pb-1">
                                                {section.title}
                                            </span>
                                        </h3>
                                        
                                        <ul className="space-y-3 pl-4 border-l border-slate-800 ml-3">
                                            {section.items.map((item, itemIdx) => (
                                                <li key={itemIdx} className="text-slate-300 leading-7">
                                                    {item.type === 'list' && (
                                                        <div className="relative pl-6">
                                                            <span className="absolute left-0 top-2.5 w-1.5 h-1.5 bg-green-500 rounded-full"></span>
                                                            <HighlightParser text={item.content} />
                                                        </div>
                                                    )}
                                                    {item.type === 'text' && (
                                                        <div className="pl-6 text-slate-400 italic">
                                                            <HighlightParser text={item.content} />
                                                        </div>
                                                    )}
                                                </li>
                                            ))}
                                        </ul>
                                    </section>
                                ))}
                            </div>

                            {/* 底部装饰 */}
                            <div className="pt-12 text-center">
                                <div className="inline-block px-4 py-2 border border-slate-800 rounded-full text-slate-600 text-xs font-mono">
                                    END OF TRANSMISSION
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>